<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>2D→3D Pussel: Kvadrat → Kub → Svärd</title>
  <style>
    :root{
      --bg:#0b0f14;--panel:rgba(255,255,255,.06);--panel2:rgba(255,255,255,.09);
      --text:rgba(255,255,255,.92);--muted:rgba(255,255,255,.65);
      --ok:#49d17d;--warn:#ffcc66;--err:#ff6680;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:radial-gradient(1200px 900px at 50% 15%,#121a24,var(--bg));color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
    button{font:inherit}
    #app{height:100%;display:grid;grid-template-rows:auto 1fr auto;gap:12px;padding:12px;max-width:1100px;margin:0 auto}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 14px;background:var(--panel);border:1px solid rgba(255,255,255,.08);border-radius:16px;backdrop-filter:blur(8px)}
    header .left{display:flex;flex-direction:column;gap:4px}
    header h1{font-size:16px;margin:0;letter-spacing:.2px}
    header .sub{font-size:12px;color:var(--muted)}
    header .right{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
    .pill{padding:6px 10px;border-radius:999px;background:var(--panel2);border:1px solid rgba(255,255,255,.1);font-size:12px;color:var(--muted);user-select:none}
    .btn{padding:8px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.08);color:var(--text);cursor:pointer}
    .btn:hover{background:rgba(255,255,255,.12)}
    .btn:active{transform:translateY(1px)}
    main{position:relative;border-radius:18px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);overflow:hidden;min-height:520px}
    footer{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 14px;background:var(--panel);border:1px solid rgba(255,255,255,.08);border-radius:16px}
    footer .hint{font-size:12px;color:var(--muted);line-height:1.35}
    footer .status{font-size:12px;color:var(--muted);display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:flex-end}
    .dot{width:8px;height:8px;border-radius:50%;background:rgba(255,255,255,.35);display:inline-block}
    .dot.ok{background:var(--ok)}
    .dot.warn{background:var(--warn)}
    .dot.err{background:var(--err)}

    .screen{position:absolute;inset:0;display:grid;place-items:center;padding:18px}
    .hidden{display:none!important}

    #phase2dWrap{width:min(980px,100%);height:min(680px,100%);display:grid;grid-template-columns:1fr 320px;gap:14px;align-items:stretch}
    @media (max-width:860px){#phase2dWrap{grid-template-columns:1fr;grid-template-rows:auto auto}}
    .panel{border-radius:16px;background:rgba(0,0,0,.15);border:1px solid rgba(255,255,255,.10);overflow:hidden;position:relative}
    .panelHeader{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08);background:rgba(255,255,255,.04);gap:10px}
    .panelHeader .title{font-size:13px;color:var(--text)}
    .panelHeader .mini{font-size:12px;color:var(--muted)}
    #svgBoard{width:100%;height:100%;touch-action:none;user-select:none;
      background:
        radial-gradient(800px 400px at 50% 20%, rgba(255,255,255,.05), transparent 70%),
        linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,.20));
    }
    .side{padding:12px;display:flex;flex-direction:column;gap:12px}
    .card{padding:12px;border-radius:14px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.05)}
    .card h2{font-size:13px;margin:0 0 6px}
    .card p{font-size:12px;margin:0;color:var(--muted);line-height:1.35}
    .kbd{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.25);font-size:12px;color:var(--text);white-space:nowrap}

    #transitionOverlay{position:absolute;inset:0;display:grid;place-items:center;
      background:radial-gradient(1000px 700px at 50% 40%, rgba(80,160,255,.18), rgba(0,0,0,.78));
      opacity:0;pointer-events:none;transition:opacity 600ms ease}
    #transitionOverlay.on{opacity:1;pointer-events:auto}
    #transitionOverlay .msg{padding:14px 16px;border-radius:16px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.35);text-align:center;width:min(460px,92%)}
    #transitionOverlay .msg h3{margin:0 0 8px;font-size:14px}
    #transitionOverlay .msg p{margin:0;font-size:12px;color:var(--muted)}

    #phase3dWrap{position:absolute;inset:0;display:grid;grid-template-columns:1fr 320px;gap:14px;padding:18px;align-items:stretch}
    @media (max-width:860px){#phase3dWrap{grid-template-columns:1fr;grid-template-rows:1fr auto}}
    #threePanel{position:relative}
    #threeCanvas{width:100%;height:100%;display:block;touch-action:none}
    .toast{position:absolute;left:12px;top:12px;padding:10px 12px;border-radius:14px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);font-size:12px;color:var(--muted);max-width:340px;backdrop-filter:blur(8px)}
    .toast b{color:var(--text)}

    main::after{content:"";position:absolute;inset:0;pointer-events:none;
      background:radial-gradient(1200px 900px at 50% 35%, transparent 55%, rgba(0,0,0,.35));opacity:.8}
  </style>
</head>

<body>
  <div id="app">
    <header>
      <div class="left">
        <h1>2D→3D Pussel: Kvadrat → Kub → Svärd</h1>
        <div class="sub" id="subtitle">Fas 1: Bygg en kvadrat av 10 asymmetriska bitar.</div>
      </div>
      <div class="right">
        <span class="pill" id="phasePill">Fas 1 / 2D</span>
        <button class="btn" id="resetBtn" title="Starta om aktuell fas">Återställ</button>
      </div>
    </header>

    <main>
      <!-- Phase 1 -->
      <section class="screen" id="phase2d">
        <div id="phase2dWrap">
          <div class="panel" id="boardPanel">
            <div class="panelHeader">
              <div class="title">2D-bräde</div>
              <div class="mini">Dra • Rotera • Snappa</div>
            </div>
            <svg id="svgBoard" viewBox="0 0 980 650" aria-label="2D puzzle board"></svg>
          </div>

          <aside class="panel">
            <div class="panelHeader">
              <div class="title">Kontroller</div>
              <div class="mini">Desktop & mobil</div>
            </div>
            <div class="side">
              <div class="card">
                <h2>Placera bitar</h2>
                <p>
                  • <span class="kbd">Dra</span> en bit med mus/finger.<br/>
                  • <span class="kbd">R</span> roterar vald bit 90° (desktop).<br/>
                  • <span class="kbd">Dubbel-tap</span> på en bit roterar 90° (mobil).<br/>
                  • När en bit är nära sin plats, <b>snappar</b> den fast.
                </p>
              </div>
              <div class="card">
                <h2>Mål</h2>
                <p>Bygg en <b>kvadrat</b>. När allt sitter: en animation, och fas 2 startar i 3D.</p>
              </div>
              <div class="card">
                <h2>Tips</h2>
                <p>Asymmetri + rotation gör det klurigt. Testa att rotera bitar innan du ger upp en placering.</p>
              </div>
            </div>
          </aside>
        </div>
      </section>

      <!-- Transition overlay -->
      <div id="transitionOverlay">
        <div class="msg">
          <h3>Förvandling…</h3>
          <p>Kvadraten “lyfter” och blir 3D. Nästa steg: bygg en kub av asymmetriska delar.</p>
        </div>
      </div>

      <!-- Phase 2 -->
      <section class="screen hidden" id="phase3d">
        <div id="phase3dWrap">
          <div class="panel" id="threePanel">
            <div class="panelHeader">
              <div class="title">3D-scen</div>
              <div class="mini">Dra delar • Rotera scenen</div>
            </div>
            <canvas id="threeCanvas"></canvas>
            <div class="toast" id="toast3d">
              <b>Fas 2:</b> Dra delarna till mitten. Rotera scenen genom att dra i bakgrunden.
            </div>
          </div>

          <aside class="panel">
            <div class="panelHeader">
              <div class="title">Kontroller</div>
              <div class="mini">3D</div>
            </div>
            <div class="side">
              <div class="card">
                <h2>Bygg kuben</h2>
                <p>
                  • <span class="kbd">Dra del</span> för att flytta den.<br/>
                  • Delar <b>snappar</b> när de är nära rätt läge/rotation.<br/>
                  • Rotera scenen genom att dra på tom yta.
                </p>
              </div>
              <div class="card">
                <h2>Slutsekvens</h2>
                <p>När kuben är klar: den roterar och pulserar svagt, sen <b>exploderar</b> den och ett <b>svärdshandtag</b> syns.</p>
              </div>
              <div class="card">
                <h2>Återställ</h2>
                <p>Klicka <span class="kbd">Återställ</span> om du vill prova från början i aktuell fas.</p>
              </div>
            </div>
          </aside>
        </div>
      </section>
    </main>

    <footer>
      <div class="hint" id="hint">
        Fas 1: Rotera bitar för att passa. (Desktop: tryck <span class="kbd">R</span> på vald bit)
      </div>
      <div class="status">
        <span><span class="dot warn" id="statusDot"></span> <span id="statusText">Pågår…</span></span>
        <span class="pill" id="progressPill">0 / 10 låsta</span>
      </div>
    </footer>
  </div>

  <script type="module">
    // =========================
    // IMPORTANT FIX:
    // Vi laddar Three.js först när fas 2 startar (dynamisk import),
    // så fas 1 alltid funkar även om 3D-moduler blockas lokalt.
    // =========================
    let THREE = null;
    let OrbitControls = null;

    async function loadThree() {
      if (THREE && OrbitControls) return;
      const threeMod = await import("https://unpkg.com/three@0.160.0/build/three.module.js");
      const controlsMod = await import("https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js");
      THREE = threeMod;
      OrbitControls = controlsMod.OrbitControls;
    }

    // =========================
    // Utilities
    // =========================
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const dist2 = (ax, ay, bx, by) => {
      const dx = ax - bx, dy = ay - by;
      return dx*dx + dy*dy;
    };
    const easeInOut = (t) => (t<0.5) ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;

    // =========================
    // Global UI
    // =========================
    const subtitle = document.getElementById("subtitle");
    const phasePill = document.getElementById("phasePill");
    const resetBtn = document.getElementById("resetBtn");
    const statusDot = document.getElementById("statusDot");
    const statusText = document.getElementById("statusText");
    const progressPill = document.getElementById("progressPill");
    const hint = document.getElementById("hint");
    const overlay = document.getElementById("transitionOverlay");

    const screen2d = document.getElementById("phase2d");
    const screen3d = document.getElementById("phase3d");

    let currentPhase = 1;

    function setStatus(kind, text) {
      statusDot.classList.remove("ok","warn","err");
      statusDot.classList.add(kind);
      statusText.textContent = text;
    }

    function setPhaseUI(phase) {
      currentPhase = phase;
      if (phase === 1) {
        subtitle.textContent = "Fas 1: Bygg en kvadrat av 10 asymmetriska bitar.";
        phasePill.textContent = "Fas 1 / 2D";
        hint.innerHTML = `Fas 1: Rotera bitar för att passa. (Desktop: tryck <span class="kbd">R</span> på vald bit)`;
      } else {
        subtitle.textContent = "Fas 2: Bygg en kub i 3D av asymmetriska delar.";
        phasePill.textContent = "Fas 2 / 3D";
        hint.textContent = "Fas 2: Dra delar till mitten. Rotera scenen genom att dra på tom yta.";
      }
    }

    // =========================
    // Phase 1: 2D SVG Puzzle
    // =========================
    const svg = document.getElementById("svgBoard");
    const BOARD_W = 980, BOARD_H = 650;

    const TARGET_SIZE = 360;
    const TARGET_X = (BOARD_W - TARGET_SIZE) / 2;
    const TARGET_Y = 120;

    const pieces2d = [];
    let selected2d = null;

    function el(name, attrs = {}) {
      const n = document.createElementNS("http://www.w3.org/2000/svg", name);
      for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, String(v));
      return n;
    }

    function setup2D() {
      svg.innerHTML = "";

      // Target outline
      svg.appendChild(el("rect",{
        x:TARGET_X,y:TARGET_Y,width:TARGET_SIZE,height:TARGET_SIZE,rx:16,
        fill:"rgba(0,0,0,0)", stroke:"rgba(255,255,255,0.18)",
        "stroke-dasharray":"8 8","stroke-width":"2"
      }));

      // Grid
      const grid = el("g",{opacity:"0.18"});
      const step = 30;
      for (let x=0; x<=BOARD_W; x+=step){
        grid.appendChild(el("line",{x1:x,y1:0,x2:x,y2:BOARD_H,stroke:"white","stroke-width":1,opacity:x%120===0?0.25:0.12}));
      }
      for (let y=0; y<=BOARD_H; y+=step){
        grid.appendChild(el("line",{x1:0,y1:y,x2:BOARD_W,y2:y,stroke:"white","stroke-width":1,opacity:y%120===0?0.25:0.12}));
      }
      svg.appendChild(grid);

      const defs = [
        { id:0, pts:"0,0 110,8 98,44 120,74 78,98 26,84 10,120 -8,70 24,38", color:"rgba(110,200,255,0.75)", target:{x:TARGET_X+10, y:TARGET_Y+20, r:0} },
        { id:1, pts:"0,10 90,0 116,34 90,66 108,110 52,120 0,92 22,56", color:"rgba(255,170,120,0.75)", target:{x:TARGET_X+120, y:TARGET_Y+18, r:90} },
        { id:2, pts:"10,0 120,18 104,60 120,96 74,120 34,102 0,120 0,44", color:"rgba(190,255,160,0.75)", target:{x:TARGET_X+250, y:TARGET_Y+14, r:180} },
        { id:3, pts:"0,0 92,10 120,40 94,70 120,120 52,110 22,84 0,60", color:"rgba(230,170,255,0.75)", target:{x:TARGET_X+18, y:TARGET_Y+140, r:270} },
        { id:4, pts:"8,0 120,8 120,62 90,70 104,120 44,112 0,120 14,60", color:"rgba(255,255,140,0.75)", target:{x:TARGET_X+135, y:TARGET_Y+145, r:0} },
        { id:5, pts:"0,0 110,0 120,34 90,60 120,90 78,120 20,106 0,70 18,40", color:"rgba(140,255,220,0.75)", target:{x:TARGET_X+240, y:TARGET_Y+140, r:90} },
        { id:6, pts:"0,20 60,0 120,12 100,52 120,82 70,120 20,100 0,70 18,42", color:"rgba(255,140,170,0.75)", target:{x:TARGET_X+20, y:TARGET_Y+255, r:180} },
        { id:7, pts:"0,0 120,0 102,42 120,70 92,92 120,120 40,112 0,120 14,54", color:"rgba(170,200,255,0.75)", target:{x:TARGET_X+135, y:TARGET_Y+260, r:270} },
        { id:8, pts:"0,10 100,0 120,30 92,64 120,90 88,120 26,110 0,82 18,52", color:"rgba(255,210,150,0.75)", target:{x:TARGET_X+250, y:TARGET_Y+260, r:0} },
        { id:9, pts:"0,0 110,14 120,50 96,64 120,92 84,120 30,110 0,120 10,52", color:"rgba(190,255,200,0.75)", target:{x:TARGET_X+130, y:TARGET_Y+375, r:180} },
      ];

      const starts = [
        {x:80,y:80},{x:820,y:90},{x:840,y:520},{x:100,y:520},{x:90,y:250},
        {x:830,y:250},{x:480,y:550},{x:480,y:60},{x:220,y:560},{x:740,y:560},
      ];

      pieces2d.length = 0;
      selected2d = null;

      const piecesLayer = el("g",{});
      svg.appendChild(piecesLayer);

      defs.forEach((d,i)=>{
        const g = el("g",{cursor:"grab"});
        const shadow = el("polygon",{points:d.pts,fill:"rgba(0,0,0,0.35)",transform:"translate(3,4)"});
        const poly = el("polygon",{
          points:d.pts,fill:d.color,stroke:"rgba(255,255,255,0.35)","stroke-width":"2","stroke-linejoin":"round"
        });
        g.appendChild(shadow);
        g.appendChild(poly);

        const state = {
          id:d.id,g,poly,
          x:starts[i].x,y:starts[i].y,
          r:[0,90,180,270][(i*7)%4],
          locked:false,
          target:d.target,
          lastTap:0,
          apply(){
            g.setAttribute("transform",`translate(${state.x} ${state.y}) rotate(${state.r})`);
            g.style.filter = state.locked ? "drop-shadow(0 0 10px rgba(73,209,125,0.35))" : "none";
            g.style.opacity = state.locked ? "0.95" : "1";
          }
        };
        state.apply();

        let dragging=false;
        let offset={x:0,y:0};

        g.addEventListener("pointerdown",(e)=>{
          if (state.locked) return;
          dragging=true;
          selected2d=state;
          g.setPointerCapture(e.pointerId);
          g.setAttribute("cursor","grabbing");
          piecesLayer.appendChild(g);

          const pt = clientToSvg(e.clientX,e.clientY);
          offset.x = pt.x - state.x;
          offset.y = pt.y - state.y;

          const now = performance.now();
          if (now - state.lastTap < 300) rotateSelected2D();
          state.lastTap = now;
        });

        g.addEventListener("pointermove",(e)=>{
          if (!dragging || state.locked) return;
          const pt = clientToSvg(e.clientX,e.clientY);
          state.x = clamp(pt.x - offset.x, -40, BOARD_W - 80);
          state.y = clamp(pt.y - offset.y, -40, BOARD_H - 80);
          state.apply();
        });

        g.addEventListener("pointerup",(e)=>{
          dragging=false;
          try{ g.releasePointerCapture(e.pointerId); }catch{}
          g.setAttribute("cursor","grab");
          trySnap2D(state);
          update2DProgress();
        });

        pieces2d.push(state);
        piecesLayer.appendChild(g);
      });

      update2DProgress();

      function clientToSvg(cx, cy){
        const rect = svg.getBoundingClientRect();
        const x = (cx - rect.left) * (BOARD_W / rect.width);
        const y = (cy - rect.top)  * (BOARD_H / rect.height);
        return {x,y};
      }
    }

    function rotateSelected2D(){
      if (!selected2d || selected2d.locked) return;
      selected2d.r = (selected2d.r + 90) % 360;
      selected2d.apply();
      trySnap2D(selected2d);
      update2DProgress();
    }

    function trySnap2D(piece){
      if (piece.locked) return;
      const target = piece.target;
      const rotMatch = (((piece.r%360)+360)%360) === (((target.r%360)+360)%360);
      const close = dist2(piece.x,piece.y,target.x,target.y) < 24*24;
      if (rotMatch && close){
        piece.x = target.x; piece.y = target.y;
        piece.locked = true;
        piece.apply();
      }
    }

    function update2DProgress(){
      const locked = pieces2d.filter(p=>p.locked).length;
      progressPill.textContent = `${locked} / 10 låsta`;

      if (locked === 10){
        setStatus("ok","Kvadraten är klar!");
        setTimeout(()=>startTransitionTo3D(), 450);
      } else {
        setStatus("warn","Pågår…");
      }
    }

    window.addEventListener("keydown",(e)=>{
      if (currentPhase !== 1) return;
      if (e.key.toLowerCase() === "r") rotateSelected2D();
    });

    // =========================
    // Transition
    // =========================
    async function startTransitionTo3D(){
      overlay.classList.add("on");

      const gAll = svg.querySelector("g");
      if (gAll){
        const start = performance.now();
        const dur = 900;
        const tick = (t)=>{
          const p = clamp((t-start)/dur,0,1);
          const k = 1 + 0.06*easeInOut(p);
          svg.style.transformOrigin = "50% 50%";
          svg.style.transform = `scale(${k})`;
          if (p<1) requestAnimationFrame(tick);
        };
        requestAnimationFrame(tick);
      }

      await new Promise(r=>setTimeout(r,900));
      svg.style.transform = "";

      screen2d.classList.add("hidden");
      screen3d.classList.remove("hidden");
      setPhaseUI(2);

      overlay.classList.remove("on");

      // init 3D (dynamisk import)
      init3D().catch(err=>{
        console.error(err);
        alert("Kunde inte ladda 3D-läget (Three.js). Kontrollera internet/CORS. Fas 1 fungerar.");
